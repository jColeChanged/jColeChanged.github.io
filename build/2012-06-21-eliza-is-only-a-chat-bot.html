<html><head><meta charset="UTF-8" /><title>Eliza is Only a Chat Bot</title><meta content="Toto document" name="description" /><meta content="" name="keywords" /><meta content="width=device-width, initial-scale=1" name="viewport" /><style>/* some style */

@font-face {
    font-family: "LatinModernRomanWOFF";
    /*src: url('https://www.albany.edu/~hammond/webfonts/lmroman12-regular.woff');*/
    src: url('http://ozviz.io/fonts/lmroman12-regular.woff');
}

/* for math fonts? */
/*@font-face {*/
    /*font-family: "LatinModernMathWOFF";*/
    /*src: url('https://www.albany.edu/~hammond/webfonts/latinmodern-math.woff');*/
    /*font-weight: bold;*/
/*}*/


body {
  padding: 30px;
  line-height: 1.7;
  font-family: 'Open Sans', sans-serif;
}

div#app {
  margin: 0;
  padding: 0;
  font-family: 'Open Sans', sans-serif;
}

blockquote {
  font-style: italic;
  color: #606060;
}

h1, h2, h3, h4 {
  font-family: "LatinModernRomanWOFF", serif;
  line-height: 1.4;
  /*font-family: 'Open Sans', sans-serif;*/
}

.fancy {
  font-family: "LatinModernRomanWOFF", serif;
}
.plain {
  font-family: 'Open Sans', sans-serif;
}

h1 {
  font-size: 50px;
  margin-top: 40px;
  margin-bottom: 20px;
}

h2{
  font-size: 30px;
  margin-top: 50px;
  margin-bottom: 15px;
}

h3 {
  font-size: 23px;
  margin-top: 40px;
  margin-bottom: 13px;
}

h4 {font-size: 18px;}

code {
  line-height: 1.5;
  font-size: 14.5px;
  color: #606060;
  margin-right: 4px;
  margin-left: 4px;
}

pre {
  line-height: 1.5;
  font-size: 14.5px;
  color: #606060;
}

a {
  color: darkblue;
}

div.vega-embed div.chart-wrapper {
  height: auto;
}


</style><link href="http://ozviz.io/fonts/lmroman12-regular.woff" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" /></head><body><div><p>I've been reading and enjoying <a href="book">Paradigms of Artificial Intelligence: Case Studies in Common Lisp</a>. It is an amazing book written by <a href="http://norvig.com/index.html">Peter Norvig</a>, formerly of NASA and now head of research at Google. Norvig has a way of talking about AI programs that shaped the field in their time in a way that educates rather than confuses.</p><p>The programs he talks about start out seeming like magic, but because he is  good at giving explanations the magic tricks quickly fade, replaced by explanation. They seem baffling and astounding. Then you find out what is <a href="http://www.youtube.com/watch?v=2H81A3bU68k">really going on</a> and it might still be cool, but its a different kind of cool. Once you know the trick behind it, the entire program is seen in a new light.</p><p>This feeling, the opposite of magic, is actually at the root of what it even means to  communicate explanations well. Magic hides the explanation for events. Norvig doesn't.</p><p>To show you what I mean I’m going to go over an AI that Norvig talks about in the book called Eliza. Eliza is a chat bot built way back when and it tricked a lot of people into thinking there was actually something intelligent behind it. That people took it seriously actually freaked out the person who coded the AI.</p><p>So what is Eliza? Eliza is a rule based translator. What does that mean? Well I’ll give you an example of a set of rules to show you. These rules are taken directly from an implementation of a subset of the features of the actual Eliza that I wrote in Clojure, one of my favorite programming languages. I’m hoping it will be pretty readable even if you aren’t familiar with the language:</p><p></p><div> <code> <pre> ("?<em>x I want ?</em>y"   ("What would it mean if you got ?*y"    "Suppose you got ?*y soon?"    "Why do you want ?*y")) </pre> </code> </div><p></p><p>So what we have above is a list of two items. The first item is a string and the second item is a list. That first string, it is a pattern. Whenever Eliza is told something it will check this rule and look at the pattern. It will then try to see if there is any point in what it was told where ‘I want’ appears. If there is it will save segments of text which will be called <code>?*x</code> and <code>?*y</code> for use. The second item in the list is another list. This list contains strings, each of which is a response. If Eliza managed to save anything to <code>?*x</code> and<code>?*y</code> it will select one of these response strings at random. Then using the saved variables it will create a new string. There is also this stage where Eliza converts things like you to me and me to you in the values it saves. So given this rule if I were to tell Eliza, “Hey you, I want to make you look simple.” It might respond, “What would it mean if you got to make me look simple.”</p><p>Eliza has a lot of rules and most of them are kind of vague. It allows you to become convinced that it knows more than it really does by being vague. It parrots things back, but leaves things open ended. Sometimes it is going to mess up and give really weird responses, but with enough patterns it can lead you into fooling yourself for a while.</p><p>Fun fact: at one point Eliza almost got a job. Prestigious medical journals were actually wondering if using Eliza to fill in for actual psychiatry might be a good idea. They wouldn’t have to pay it much after all. Remember when I said the author was a little bothered by how seriously people were taking the program? I wonder what sort of things might have brought that on.</p><p>Despite all of this, it was actually pretty cool to implement. Usually I would use regular expressions to match a pattern in a string, but this time I got to see how matching patterns can be done at a lower level. Now if you’re interested in all of that you can check out some of the code in a <a href="https://gist.github.com/2970757">github gist</a>. Be warned…. I’m using mutually recursive functions and there are a whole lot of parentheses.</p><p>[book]: https://www.amazon.com/gp/product/1558601910/ref=as<i>li</i>tl?ie=UTF8&tag=joshuacoles-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=1558601910&linkId=d42b5a7ed5037f5566cabdb8ca59f9cb</p></div></body></html>