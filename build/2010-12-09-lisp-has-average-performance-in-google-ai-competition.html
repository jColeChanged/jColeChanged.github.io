<html><head><meta charset="UTF-8" /><title>Lisp Has Average Performance in Google AI Competition</title><meta content="Toto document" name="description" /><meta content="" name="keywords" /><meta content="width=device-width, initial-scale=1" name="viewport" /><style>/* some style */

@font-face {
    font-family: "LatinModernRomanWOFF";
    /*src: url('https://www.albany.edu/~hammond/webfonts/lmroman12-regular.woff');*/
    src: url('http://ozviz.io/fonts/lmroman12-regular.woff');
}

/* for math fonts? */
/*@font-face {*/
    /*font-family: "LatinModernMathWOFF";*/
    /*src: url('https://www.albany.edu/~hammond/webfonts/latinmodern-math.woff');*/
    /*font-weight: bold;*/
/*}*/


body {
  padding: 30px;
  line-height: 1.7;
  font-family: 'Open Sans', sans-serif;
}

div#app {
  margin: 0;
  padding: 0;
  font-family: 'Open Sans', sans-serif;
}

blockquote {
  font-style: italic;
  color: #606060;
}

h1, h2, h3, h4 {
  font-family: "LatinModernRomanWOFF", serif;
  line-height: 1.4;
  /*font-family: 'Open Sans', sans-serif;*/
}

.fancy {
  font-family: "LatinModernRomanWOFF", serif;
}
.plain {
  font-family: 'Open Sans', sans-serif;
}

h1 {
  font-size: 50px;
  margin-top: 40px;
  margin-bottom: 20px;
}

h2{
  font-size: 30px;
  margin-top: 50px;
  margin-bottom: 15px;
}

h3 {
  font-size: 23px;
  margin-top: 40px;
  margin-bottom: 13px;
}

h4 {font-size: 18px;}

code {
  line-height: 1.5;
  font-size: 14.5px;
  color: #606060;
  margin-right: 4px;
  margin-left: 4px;
}

pre {
  line-height: 1.5;
  font-size: 14.5px;
  color: #606060;
}

a {
  color: darkblue;
}

div.vega-embed div.chart-wrapper {
  height: auto;
}


</style><link href="http://ozviz.io/fonts/lmroman12-regular.woff" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" /></head><body><div><p>The first step was to get the data. To do that I used a really cool scraping library called [Enlive][3] which lets you scrape HTML using CSS selectors. Enlive is actually a templating library, but it allows for such clean separation of presentation and logic that it handles scraping too.</p><p>Here is a [public google spreadsheet][4] that has the scraped data.</p><p>The next step was to come up with some questions to answer. I've read a lot of the writing of Paul Graham, including his strong advocation for Lisp. So some of the questions which popped into my head as worth investigating were related to the truth of the language's superiority. I wondered things like, “Is Java really the language of the average programmer?” and “How did Lisp do in comparison to Java?”</p><p>Unfortunately, those questions can't be answered with these rankings for several reasons, including [selection bias][5]. There is a sample bias in the dataset. Average programmers aren't joining AI competitions. So I had to come up with a better, more narrow, set of question.</p><p>My second go produced much tamer variants of the previous questions. The first was: How close to the average are the Java programmers in this tournament? Unfortunately, it would be a while before I managed to answer that, as I had to fix a bug. Where did bug come from? The answer will shock you. Canada. Yep, you heard that right, it came from Canada. Here is the proof, see how this Canadian doesn't come from an organization? My code expected a string.</p><p></p><figure> <img alt="Snippet of Google AI Competition Rankings" src="/img/ai-comp/snippet.png" /> </figure><p></p><p>That really <em>bugged</em> me, but I ended up getting my hat on straight. It turned out that the average elo of all the programs was about 2030, while the average elo of the Java programs was close to 2060. This is well within one standard deviation so to the answer to my first question is that Java programs are pretty average.</p><p>The second question was also fairly tame. I asked whether or not Lisp programs tended to do better than Java programs. It turned out that they didn't. The average Lisp programs elo was 2040. Which is lower than Java, which I wouldn't expect given the sort of things that Paul Graham says about Lisp. This intrigued me enough to try to ask the same question in a different way. There are multiple measures of center after all. That investigation led to a box plot of the Java and Lisp elo scores.</p><p></p><figure> <img alt="Boxplot of Java and Lisp Elo Rankings" src="/img/ai-comp/boxplot.png" /> </figure><p></p><p>I noticed when I looked at this was that the winner of the competition, a Lisp program, was an outlier. That seems to go against some of the [language attribution][8] that was going on when the winner was first announced. Lisp does gets a little redemption though as the median Lisp program was a good bit above the average. This means that most of the Lisp programs were above average, but the ones that weren't tended to be so below average as to drag them down. The [density diagram][9] shown on the blog that I mentioned earlier seems to support this assessment.</p><p>The programming competition hasn't shown Lisp to be special. Though most Lisp users ranked above the median, they were even closer to average than Java. Java on the other hand was just as expected, average to the core.</p><p>That wasn't what I expected going into this, so I'm glad I got this result.</p><p>[1]: https://web.archive.org/web/20120204055202/http://www.r-chart.com/2010/12/google-ai-challenge-languages-used-by.html [2]: https://web.archive.org/web/20101104134158/http://www.r-chart.com/ [3]: https://github.com/cgrand/enlive [4]: https://spreadsheets.google.com/ccc?key=0AmdrW-WZLahvdEotcEY4VnJIMGtEWjNueXNzeElDcUE&hl=en [5]: http://en.wikipedia.org/wiki/Selection_bias</p><p>[8]: http://www.zdnet.com/blog/burnette/hungarian-lisp-developer-walks-away-with-google-ai-contest/2131 [9]: http://3.bp.blogspot.com/<i>FsLa1cMTCWU/TPgyBXF3PhI/AAAAAAAAAjg/M6v-8WEvv98/s1600/lisp</i>density_plot.png</p></div></body></html>